在这最后一章,我们将回到`:kv`应用程序然后添加一个路由层,允许我们分发基于桶名字节点之间的请求。

路由层将收到一个下面格式的路由表:

    [{?a..?m, :"foo@computer-name"},
     {?n..?z, :"bar@computer-name"}]

路由器在路由表内检索“桶”名的第一个字节，然后根据检索结果分派合适的节点。例如，一个“桶”的名称以"a"开头(`?a`表示字母"a"的unicode码位)将会被分派到`foo@computer-name`节点。

如果匹配的条目指向处理请求的节点，路由工作就完成了，这个节点将会执行请求的操作。如果匹配的条目指向一个不同的节点，将请求传递都这个节点，然后根据自己的路由表（可能和第一个节点的路由表不同）执行。如果没有条目匹配，将会抛出错误。

你或许想知道为什么不让由自己路由表查找到的节点直接处理操作，而是传递路由请求到那个处理。像上面这样简单的路由表或许要在所有节点之间共享，以这种方式传递路由请求的原因是随着应用程序增长，可以更简单的将路由表分成较小的部分。或许以后,`foo@computer-name`只会负责“桶”的路由请求,桶处理器则会被派往不同的节点。这样,`bar@computer-name`不需要知道任何变化的信息。

> 注意：本章我们将在一台机器上使用两个节点。你也可以使用同一网络环境中两个（或更多）的机器，前提是要做预备工作。首先，要确保所有机器的`～/.erlang.cookie`文件内有相同的值。其次，确保[epmd](http://www.erlang.org/doc/man/epmd.html)运行的端口没有被阻拦（可以使用`epmd -d`获取调试信息）。如果你想学习更多关于分布的常用信息，我们建议看看[Learn You Some Erlang的Distribunomicon这一章](http://learnyousomeerlang.com/distribunomicon)。

## 10.1 我们第一个分布式代码

Elixir提供了节点间连接和交换信息的工具。实际上，在分布式环境下，进程、消息传递和接收这些概念都不变，因为 Elixir进程是*位置透明*。也就是说发送一个消息时，接收消息的进程在相同或不同的节点不重要，虚拟机都可以传递消息。

为了执行分布式代码，需要以一个名字启动虚拟机。名字可短（相同网络环境下）可长（需要完整计算机地址）。让我们启动一个新的IEx会话：

    $ iex --sname foo

现在可以看到提示符发生了一些变化，计算机名后显示了节点名称：

    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)
    iex(foo@jv)1>

我计算机的名字是`jv`，所以上面的例子看到的是`foo@jv`，你会有不同的显示。接下来的例子，我们将使用`jv@computer-name`作为名字，根据尝试的代码你应该更新它们的值。

让我们在shell里定义一个叫`Hello`模块名：

```iex
iex> defmodule Hello do
...>  def world, do: IO.puts "hello world"
...> end
```

如果在相同网络里，有另外一个装好Erlang和Elixir的计算机，你可以开启在这个计算机上开启另一个shell。没有俩电脑的话，直接在另一个终端中开启一个新IEx会话。两种情况下都使用`bar`作为短名字：

    $ iex --sname bar

注意在新的IEx会话中，我们无法使用`Hello.world/0`函数：

```iex
iex> Hello.world
** (UndefinedFunctionError) undefined function: Hello.world/0
    Hello.world()
```

然而我们可以在`bar@computer-name`上给`foo@computer-name`节点生成一个新进程!让我们试一试（`@computer-name`是你本地看到名字）：

```iex
iex> Node.spawn_link :"foo@computer-name", fn -> Hello.world end
#PID<9014.59.0>
hello world
```

Elixir在另外节点生成一个进程然后返回它的进程号。代码将会在其他节点调用已存在的`Hello.world/0`函数。注意到结果"hello world"是在当前节点`bar`而不是`foo`节点打印出来的。换句话说，消息将会从`foo`节点发回到`bar`节点。会发生这样的情况是因为在其他节点(`foo`)生成的进程的进程组长(group leader)是当前节点(`bar`)。我们在[IO章节](http://elixir-lang.org/getting_started/12.html)简要的谈到过进程组长。

我们照样可以给`Node.spawn_link/2`返回的进程号发送和接收信息。让我们试一试ping-pong：

```iex
iex> pid = Node.spawn_link :"foo@computer-name", fn ->
...>   receive do
...>     {:ping, client} -> send client, :pong
...>   end
...> end
#PID<9014.59.0>
iex> send pid, {:ping, self}
{:ping, #PID<0.73.0>}
iex> flush
:pong
:ok
```

以我们的快速的了解,可以得出这样的结论:当需要进行分布式计算时，应该直接使用`Node.spawn_link/2`函数在远程节点上生成进程。然而通过之前的教程学习了应该尽可能的避免在监控树外生成进程，所以我们需要另外的解决方法。

有三个比`Node.spawn_link/2`更好的选择：

1. 使用Erlang的[:rpc](http://erlang.org/doc/man/rpc.html)模块，进行远程节点调用执行。在`bar@computer-name`节点的shell中调用`:rpc.call(:"foo@computer-name", Hello, :world, [])`将会打印"hello world"信息。

2. 让服务器运行在其他节点，然后使用[GenServer](http://elixir-lang.org/docs/stable/elixir/GenServer.html)API向这个节点发送请求。例如，你可以使用`GenServer.call({name, node}, arg)`函数向一个远程命名服务器发送请求，或者直接将远端的进程号作为第一个参数进行传递。

3. 上一章使用的任务(tasks)模块，因为在本地和远程节点都可以生成。

上面的方法有不同的特点。使用通用服务器和`:rpc`将会在一个单独的服务器依次接收请求，任务则很有效率的在远程节点异步执行，只有生成进程是由监控器依次完成。

对与我们的路由层，将使用任务模块，你也可以尝试使用其他方法。

## 10.2 异步/等待

目前我们已经知道任务是隔离运行且对于返回值是不关心的。然而，有时候执行计算任务并读取返回的结果也是很有用的。因此，任务模块同样提供了`async/await`模式：

```elixir
task = Task.async(fn -> compute_something_expensive end)
res  = compute_something_else()
res + Task.await(task)
```

`async/await`为计算提供了一个非常简单的并行机制。不仅如此，和之前章节一样，`async/await`也可以用来和[`Task.Supervisor`](http://elixir-lang.org/docs/stable/elixir/Task.Supervisor.html)搭配。只需要将`Task.Supervisor.start_child/2`代替为`Task.Supervisor.async/2`，用`Task.await/2`读取结果。

## 10.3 Distributed tasks

Distributed tasks are exactly the same as supervised tasks. The only difference is that we pass the node name when spawning the task on the supervisor. Open up `lib/kv/supervisor.ex` from the `:kv` application. Let's add a task supervisor to the tree:

```elixir
supervisor(Task.Supervisor, [[name: KV.RouterTasks]]),
```

Now, let's start two named nodes again, but inside the `:kv` application:

    $ iex --sname foo -S mix
    $ iex --sname bar -S mix

From inside `bar@computer-name`, we can now spawn a task directly on the other node via the supervisor:

```iex
iex> task = Task.Supervisor.async {KV.RouterTasks, :"foo@computer-name"}, fn ->
...>   {:ok, node()}
...> end
%Task{pid: #PID<12467.88.0>, ref: #Reference<0.0.0.400>}
iex> Task.await(task)
{:ok, :"foo@computer-name"}
```

Our first distributed task is straightforward: it simply gets the name of the node the task is running on. With this knowledge in hand, let's finally write the routing code.

## 10.4 Routing layer

Create a file at `lib/kv/router.ex` with the following contents:

```elixir
defmodule KV.Router do
  @doc """
  Dispatch the given `mod`, `fun`, `args` request
  to the appropriate node based on the `bucket`.
  """
  def route(bucket, mod, fun, args) do
    # Get the first byte of the binary
    first = :binary.first(bucket)

    # Try to find an entry in the table or raise
    entry =
      Enum.find(table, fn {enum, node} ->
        first in enum
      end) || no_entry_error(bucket)

    # If the entry node is the current node
    if elem(entry, 1) == node() do
      apply(mod, fun, args)
    else
      sup = {KV.RouterTasks, elem(entry, 1)}
      Task.Supervisor.async(sup, fn ->
        KV.Router.route(bucket, mod, fun, args)
      end) |> Task.await()
    end
  end

  defp no_entry_error(bucket) do
    raise "could not find entry for #{inspect bucket} in table #{inspect table}"
  end

  @doc """
  The routing table.
  """
  def table do
    # Replace computer-name with your local machine name.
    [{?a..?m, :"foo@computer-name"},
     {?n..?z, :"bar@computer-name"}]
  end
end
```

Let's write a test to verify our router works. Create a file named `test/kv/router_test.exs` containing:

```elixir
defmodule KV.RouterTest do
  use ExUnit.Case, async: true

  test "route requests accross nodes" do
    assert KV.Router.route("hello", Kernel, :node, []) ==
           :"foo@computer-name"
    assert KV.Router.route("world", Kernel, :node, []) ==
           :"bar@computer-name"
  end

  test "raises on unknown entries" do
    assert_raise RuntimeError, ~r/could not find entry/, fn ->
      KV.Router.route(<<0>>, Kernel, :node, [])
    end
  end
end
```

The first test simply invokes `Kernel.node/0`, which returns the name of the current node, based on the bucket names "hello" and "world". According to our routing table so far, we should get `foo@computer-name` and `bar@computer-name` as responses, respectively.

The second test just checks that the code raises for unknown entries.

In order to run the first test, we need to have two nodes running. Let's restart the node named `bar`, which is going to be used by tests:

    $ iex --sname bar -S mix

And now run tests with:

    $ elixir --sname foo -S mix test

Our test should successfuly pass. Excellent!

## 10.5 Test filters and tags

Although our tests pass, our testing structure is getting more complex. In particular, running tests with only `mix test` causes failures in our suite, since our test requires a connection to another node.

Luckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags.

All we need to do to tag a test is simply call `@tag` before the test name. Back to `test/kv/routest_test.exs`, let's add a `:distributed` tag:

```elixir
@tag :distributed
test "route requests accross nodes" do
```

Writing `@tag :distributed` is equivalent to writing `@tag distributed: true`.

With the test properly tagged, we can now check if the node is alive on the network and, if not, we can exclude all distributed tests. Open up `test/test_helper.exs` inside the `:kv` application and add the following:

```elixir
exclude =
  if Node.alive?, do: [], else: [distributed: true]

ExUnit.start(exclude: exclude)
```

Now run tests with `mix test`:

    $ mix test
    Excluding tags: [distributed: true]

    .......

    Finished in 0.1 seconds (0.1s on load, 0.01s on tests)
    7 tests, 0 failures

This time all tests passed and ExUnit warned us that distributed tests were being excluded. If you run tests with `$ elixir --sname foo -S mix test`, one extra test should run and successfully pass as long as the `bar@computer-name` node is available.

The `mix test` command also allows us to dynamically include and exclude tags. For example, we can run `$ mix test --include distributed` to run distributed tests regardless of the value set in `test/test_helper.exs`. We could also pass `--exclude` to exclude a particular tag from the command line. Finally, `--only` can be used to run only tests with a particular tag:

    $ elixir --sname foo -S mix test --only distributed

You can read more about filters, tags and the default tags in [`ExUnit.Case` module documentation](/docs/stable/ex_unit/ExUnit.Case.html).

## 10.6 Application environment and configuration

So far we have hardcoded the routing table into the `KV.Router` module. However, we would like to make the table dynamic. This allows us not only to configure development/test/production, but also to allow different nodes to run with different entries in the routing table. There is a feature of OTP that does exactly that: the application environment.

Each application has an environment that stores the application specific configuration by key. For example, we could store the routing table in the `:kv` application environment, giving it a default value and allowing other applications to change the table as needed.

Open up `apps/kv/mix.exs` and change the `application/0` function to return the following:

```elixir
def application do
  [applications: [],
   env: [routing_table: []],
   mod: {KV, []}]
end
```

We have added a new `:env` key to the application. It returns the application default environment, which has an entry of key `:routing_table` and value of an empty list. It makes sense for the application environment to ship with an empty table, as the specific routing table depends on the testing/deployment structure.

In order to use the application environment in our code, we just need to replace `KV.Router.table/0` with the definition below:

```elixir
@doc """
The routing table.
"""
def table do
  Application.get_env(:kv, :routing_table)
end
```

We use `Application.get_env/2` to read the entry for `:routing_table` in `:kv`'s environment. You can find more information and other functions to manipulate the app environment in the [Application module](/docs/stable/elixir/Application.html).

Since our routing table is now empty, our distributed test should fail. Restart the apps and re-run tests to see the failure:

    $ iex --sname bar -S mix
    $ elixir --sname foo -S mix test --only distributed

The interesting thing about the application environment is that it can be configured not only for the current application, but for all applications. Such configuration is done by the `config/config.exs` file. For example, we can configure IEx default prompt to another value. Just open `apps/kv/config/config.exs` and add the following to the end:

```elixir
config :iex, default_prompt: ">>>"
```

Start IEx with `iex -S mix` and you can see that the IEx prompt has changed.

This means we can configure our `:routing_table` directly in the `config/config.exs` file as well:

```elixir
# Replace computer-name with your local machine nodes.
config :kv, :routing_table,
       [{?a..?m, :"foo@computer-name"},
        {?n..?z, :"bar@computer-name"}]
```

Restart the nodes and run distributed tests again. Now they should all pass.

Each application has its own `config/config.exs` file and they are not shared in any way. Configuration can also be set per environment. Read the contents of the config file for the `:kv` application for more information on how to do so.

Since config files are not shared, if you run tests from the umbrella root, they will fail because the configuration we just added to `:kv` is not available there. However, if you open up `config/config.exs` in the umbrella, it has instructions on how to import config files from children applications. You just need to invoke:

```elixir
import_config "../apps/kv/config/config.exs"
```

The `mix run` command also accepts a `--config` flag, which allows configuration files to be given on demand. This could be used to start different nodes, each with its own specific configuration (for example, different routing tables).

Overall, the built-in ability to configure applications and the fact that we have built our software as an umbrella application gives us plenty of options when deploying the software. We can:

* deploy the umbrella application to a node that will work as both TCP server and key-value storage

* deploy the `:kv_server` application to work only as a TCP server as long as the routing table points only to other nodes

* deploy only the `:kv` application when we want a node to work only as storage (no TCP access)

As we add more applications in the future, we can continue controlling our deploy with the same level of granularity, cherry-picking which applications with which configuration are going to production. We can also consider building multiple releases with a tool like [exrm](https://github.com/bitwalker/exrm), which will package the chosen applications and configuration, including the current Erlang and Elixir installations, so we can deploy the application even if the runtime is not pre-installed on the target system.

Finally, we have learned some new things in this chapter, and they could be applied to the `:kv_server` application as well. We are going to leave the next steps as an exercise:

* change the `:kv_server` application to read the port from its application environment instead of using the hardcoded value of 4040

* change and configure the `:kv_server` application to use the routing functionality instead of dispatching directly to the local `KV.Registry`. For `:kv_server` tests, you can make the routing table simply point to the current node itself

## 10.7 Summing up

In this chapter we have built a simple router as a way to explore the distributed features of Elixir and the Erlang VM, and learned how to configure its routing table. This is the last chapter in our Mix and OTP guide.

Throughout the guide, we have built a very simple distributed key-value store as an opportunity to explore many constructs like generic servers, event managers, supervisors, tasks, agents, applications and more. Not only that, we have written tests for the whole application, getting familiar with ExUnit, and learned how to use the Mix build tool to accomplish a wide range of tasks.

If you are looking for a distributed key-value store to use in production, you should definitely look into [Riak](http://basho.com/riak/), which also runs in the Erlang VM. In Riak, the buckets are replicated, to avoid data loss, and instead of a router, they use [consistent hashing](http://en.wikipedia.org/wiki/Consistent_hashing) to map a bucket to a node. A consistent hashing algorithm helps reduce the amount of data that needs to be migrated when new nodes to store buckets are added to your infrastructure.
