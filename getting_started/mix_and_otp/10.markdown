在这最后一章,我们将回到`:kv`应用程序然后添加一个路由层,允许我们分发基于桶名字节点之间的请求。

路由层将收到一个下面格式的路由表:

    [{?a..?m, :"foo@computer-name"},
     {?n..?z, :"bar@computer-name"}]

路由器在路由表内检索“桶”名的第一个字节，然后根据检索结果分派合适的节点。例如，一个“桶”的名称以"a"开头(`?a`表示字母"a"的unicode码位)将会被分派到`foo@computer-name`节点。

如果匹配的条目指向处理请求的节点，路由工作就完成了，这个节点将会执行请求的操作。如果匹配的条目指向一个不同的节点，将请求传递都这个节点，然后根据自己的路由表（可能和第一个节点的路由表不同）执行。如果没有条目匹配，将会抛出错误。

你或许想知道为什么不让由自己路由表查找到的节点直接处理操作，而是传递路由请求到那个处理。像上面这样简单的路由表或许要在所有节点之间共享，以这种方式传递路由请求的原因是随着应用程序增长，可以更简单的将路由表分成较小的部分。或许以后,`foo@computer-name`只会负责“桶”的路由请求,桶处理器则会被派往不同的节点。这样,`bar@computer-name`不需要知道任何变化的信息。

> 注意：本章我们将在一台机器上使用两个节点。你也可以使用同一网络环境中两个（或更多）的机器，前提是要做预备工作。首先，要确保所有机器的`～/.erlang.cookie`文件内有相同的值。其次，确保[epmd](http://www.erlang.org/doc/man/epmd.html)运行的端口没有被阻拦（可以使用`epmd -d`获取调试信息）。如果你想学习更多关于分布的常用信息，我们建议看看[Learn You Some Erlang的Distribunomicon这一章](http://learnyousomeerlang.com/distribunomicon)。

## 10.1 我们第一个分布式代码

Elixir提供了节点间连接和交换信息的工具。实际上，在分布式环境下，进程、消息传递和接收这些概念都不变，因为 Elixir进程是*位置透明*。也就是说发送一个消息时，接收消息的进程在相同或不同的节点不重要，虚拟机都可以传递消息。

为了执行分布式代码，需要以一个名字启动虚拟机。名字可短（相同网络环境下）可长（需要完整计算机地址）。让我们启动一个新的IEx会话：

    $ iex --sname foo

现在可以看到提示符发生了一些变化，计算机名后显示了节点名称：

    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)
    iex(foo@jv)1>

我计算机的名字是`jv`，所以上面的例子看到的是`foo@jv`，你会有不同的显示。接下来的例子，我们将使用`jv@computer-name`作为名字，根据尝试的代码你应该更新它们的值。

让我们在shell里定义一个叫`Hello`模块名：

```iex
iex> defmodule Hello do
...>  def world, do: IO.puts "hello world"
...> end
```

如果在相同网络里，有另外一个装好Erlang和Elixir的计算机，你可以开启在这个计算机上开启另一个shell。没有俩电脑的话，直接在另一个终端中开启一个新IEx会话。两种情况下都使用`bar`作为短名字：

    $ iex --sname bar

注意在新的IEx会话中，我们无法使用`Hello.world/0`函数：

```iex
iex> Hello.world
** (UndefinedFunctionError) undefined function: Hello.world/0
    Hello.world()
```

然而我们可以在`bar@computer-name`上给`foo@computer-name`节点生成一个新进程!让我们试一试（`@computer-name`是你本地看到名字）：

```iex
iex> Node.spawn_link :"foo@computer-name", fn -> Hello.world end
#PID<9014.59.0>
hello world
```

Elixir在另外节点生成一个进程然后返回它的进程号。代码将会在其他节点调用已存在的`Hello.world/0`函数。注意到结果"hello world"是在当前节点`bar`而不是`foo`节点打印出来的。换句话说，消息将会从`foo`节点发回到`bar`节点。会发生这样的情况是因为在其他节点(`foo`)生成的进程的进程组长(group leader)是当前节点(`bar`)。我们在[IO章节](http://elixir-lang.org/getting_started/12.html)简要的谈到过进程组长。

我们照样可以给`Node.spawn_link/2`返回的进程号发送和接收信息。让我们试一试ping-pong：

```iex
iex> pid = Node.spawn_link :"foo@computer-name", fn ->
...>   receive do
...>     {:ping, client} -> send client, :pong
...>   end
...> end
#PID<9014.59.0>
iex> send pid, {:ping, self}
{:ping, #PID<0.73.0>}
iex> flush
:pong
:ok
```

以我们的快速的了解,可以得出这样的结论:当需要进行分布式计算时，应该直接使用`Node.spawn_link/2`函数在远程节点上生成进程。然而通过之前的教程学习了应该尽可能的避免在监控树外生成进程，所以我们需要另外的解决方法。

有三个比`Node.spawn_link/2`更好的选择：

1. 使用Erlang的[:rpc](http://erlang.org/doc/man/rpc.html)模块，进行远程节点调用执行。在`bar@computer-name`节点的shell中调用`:rpc.call(:"foo@computer-name", Hello, :world, [])`将会打印"hello world"信息。

2. 让服务器运行在其他节点，然后使用[GenServer](http://elixir-lang.org/docs/stable/elixir/GenServer.html)API向这个节点发送请求。例如，你可以使用`GenServer.call({name, node}, arg)`函数向一个远程命名服务器发送请求，或者直接将远端的进程号作为第一个参数进行传递。

3. 上一章使用的任务(tasks)模块，因为在本地和远程节点都可以生成。

上面的方法有不同的特点。使用通用服务器和`:rpc`将会在一个单独的服务器依次接收请求，任务则很有效率的在远程节点异步执行，只有生成进程是由监控器依次完成。

对与我们的路由层，将使用任务模块，你也可以尝试使用其他方法。

## 10.2 异步/等待

目前我们已经知道任务是隔离运行且对于返回值是不关心的。然而，有时候执行计算任务并读取返回的结果也是很有用的。因此，任务模块同样提供了`async/await`模式：

```elixir
task = Task.async(fn -> compute_something_expensive end)
res  = compute_something_else()
res + Task.await(task)
```

`async/await`为计算提供了一个非常简单的并行机制。不仅如此，和之前章节一样，`async/await`也可以用来和[`Task.Supervisor`](http://elixir-lang.org/docs/stable/elixir/Task.Supervisor.html)搭配。只需要将`Task.Supervisor.start_child/2`代替为`Task.Supervisor.async/2`，用`Task.await/2`读取结果。

## 10.3 分布式任务

分布式任务和被监控的任务一样。唯一不同的是生成任务的时候我们将节点的名字传递给监控器。打开`:kv`的`lib/kv/supervisor.ex`文件，让我们在监控树中增加一个任务监控器：

```elixir
supervisor(Task.Supervisor, [[name: KV.RouterTasks]]),
```

现在在`:kv`程序内开启两个命名节点：

    $ iex --sname foo -S mix
    $ iex --sname bar -S mix

在`bar@computer-name`节点，通过监控器就可以直接生成一个任务：

```iex
iex> task = Task.Supervisor.async {KV.RouterTasks, :"foo@computer-name"}, fn ->
...>   {:ok, node()}
...> end
%Task{pid: #PID<12467.88.0>, ref: #Reference<0.0.0.400>}
iex> Task.await(task)
{:ok, :"foo@computer-name"}
```

我们第一个分布式任务很简单：获取正在运行任务的节点名。知道了这个，最后让我们编写路由编码：

## 10.4 路由层

用以下内容创建`lib/kv/router.ex`文件:

```elixir
defmodule KV.Router do
  @doc """
  Dispatch the given `mod`, `fun`, `args` request
  to the appropriate node based on the `bucket`.
  """
  def route(bucket, mod, fun, args) do
    # Get the first byte of the binary
    first = :binary.first(bucket)

    # Try to find an entry in the table or raise
    entry =
      Enum.find(table, fn {enum, node} ->
        first in enum
      end) || no_entry_error(bucket)

    # If the entry node is the current node
    if elem(entry, 1) == node() do
      apply(mod, fun, args)
    else
      sup = {KV.RouterTasks, elem(entry, 1)}
      Task.Supervisor.async(sup, fn ->
        KV.Router.route(bucket, mod, fun, args)
      end) |> Task.await()
    end
  end

  defp no_entry_error(bucket) do
    raise "could not find entry for #{inspect bucket} in table #{inspect table}"
  end

  @doc """
  The routing table.
  """
  def table do
    # Replace computer-name with your local machine name.
    [{?a..?m, :"foo@computer-name"},
     {?n..?z, :"bar@computer-name"}]
  end
end
```

让我们写一个测试来确认路由器工作。创建一个名为`test/kv/router_test.exs`包含下面内容：

```elixir
defmodule KV.RouterTest do
  use ExUnit.Case, async: true

  test "route requests accross nodes" do
    assert KV.Router.route("hello", Kernel, :node, []) ==
           :"foo@computer-name"
    assert KV.Router.route("world", Kernel, :node, []) ==
           :"bar@computer-name"
  end

  test "raises on unknown entries" do
    assert_raise RuntimeError, ~r/could not find entry/, fn ->
      KV.Router.route(<<0>>, Kernel, :node, [])
    end
  end
end
```

第一个测试直接调用`Kernel.node/0`函数，基于“桶”名"hello"和"world"返回当前的节点名。根据我们目前的路由表，我们应该分别得到`foo@computer-name`和`bar@computer-name`回应。

第二个测试为了检查未知条目，抛出错误。

为了执行第一个测试，我们需要运行两个节点。让我们重启将要被测试使用的节点`bar`：

    $ iex --sname bar -S mix

用以下命令执行测试：

    $ elixir --sname foo -S mix test

我们测试应该成功通过。太好了！

## 10.5 测试的过滤器和标签

尽管我们测试通过了，但是我们测试结构变的更复杂了。特别是使用`mix test`执行测试会导致测试失败，因为我们的测试需要连接到另一个节点。

幸运的是，ExUnit附带了一个标记测试的工具，基于标签,允许执行指定的回调，甚至过滤测试。

给测试加一个标签所有需要做的就是在测试名前调用`@tag`。回到`test/kv/router_test.exs`,增加一个`:distributed`标签：

```elixir
@tag :distributed
test "route requests accross nodes" do
```

`@tag :distributed`相当于`@tag distributed: true`

合适的增加标签，我们就可以检查节点是否在线，若不在线就可以排除分布式测试。打开`:kv`程序内的`test/test_helper.exs`文件，添加如下代码：

```elixir
exclude =
  if Node.alive?, do: [], else: [distributed: true]

ExUnit.start(exclude: exclude)
```

现在用`mix test`执行测试：

    $ mix test
    Excluding tags: [distributed: true]

    .......

    Finished in 0.1 seconds (0.1s on load, 0.01s on tests)
    7 tests, 0 failures

这次的测试会通过，ExUnit警告我们分布式测试被排除了。如果你使用`$ elixir --sname foo -S mix test`执行测试，会多执行一个测试（就是那个被排除的分布式测试），而且只要`bar@computer-name`可用，测试就会成功！

`mix test`命令同样允许动态的包含和排除标签。例如，可以运行`$ mix test --include distributed`执行分布式测试而忽略`test/test_helper.exs`里的值。也可以给命令行传递`--exclude`选项来排除特定的标签。`--only`可以用来只运行特定的标签:

    $ elixir --sname foo -S mix test --only distributed

你可以在[`ExUnit.Case`模块文档](/docs/stable/ex_unit/ExUnit.Case.html)中读到更多关于过滤器、标签和默认标签。

## 10.6 Application environment and configuration

So far we have hardcoded the routing table into the `KV.Router` module. However, we would like to make the table dynamic. This allows us not only to configure development/test/production, but also to allow different nodes to run with different entries in the routing table. There is a feature of OTP that does exactly that: the application environment.

Each application has an environment that stores the application specific configuration by key. For example, we could store the routing table in the `:kv` application environment, giving it a default value and allowing other applications to change the table as needed.

Open up `apps/kv/mix.exs` and change the `application/0` function to return the following:

```elixir
def application do
  [applications: [],
   env: [routing_table: []],
   mod: {KV, []}]
end
```

We have added a new `:env` key to the application. It returns the application default environment, which has an entry of key `:routing_table` and value of an empty list. It makes sense for the application environment to ship with an empty table, as the specific routing table depends on the testing/deployment structure.

In order to use the application environment in our code, we just need to replace `KV.Router.table/0` with the definition below:

```elixir
@doc """
The routing table.
"""
def table do
  Application.get_env(:kv, :routing_table)
end
```

We use `Application.get_env/2` to read the entry for `:routing_table` in `:kv`'s environment. You can find more information and other functions to manipulate the app environment in the [Application module](/docs/stable/elixir/Application.html).

Since our routing table is now empty, our distributed test should fail. Restart the apps and re-run tests to see the failure:

    $ iex --sname bar -S mix
    $ elixir --sname foo -S mix test --only distributed

The interesting thing about the application environment is that it can be configured not only for the current application, but for all applications. Such configuration is done by the `config/config.exs` file. For example, we can configure IEx default prompt to another value. Just open `apps/kv/config/config.exs` and add the following to the end:

```elixir
config :iex, default_prompt: ">>>"
```

Start IEx with `iex -S mix` and you can see that the IEx prompt has changed.

This means we can configure our `:routing_table` directly in the `config/config.exs` file as well:

```elixir
# Replace computer-name with your local machine nodes.
config :kv, :routing_table,
       [{?a..?m, :"foo@computer-name"},
        {?n..?z, :"bar@computer-name"}]
```

Restart the nodes and run distributed tests again. Now they should all pass.

Each application has its own `config/config.exs` file and they are not shared in any way. Configuration can also be set per environment. Read the contents of the config file for the `:kv` application for more information on how to do so.

Since config files are not shared, if you run tests from the umbrella root, they will fail because the configuration we just added to `:kv` is not available there. However, if you open up `config/config.exs` in the umbrella, it has instructions on how to import config files from children applications. You just need to invoke:

```elixir
import_config "../apps/kv/config/config.exs"
```

The `mix run` command also accepts a `--config` flag, which allows configuration files to be given on demand. This could be used to start different nodes, each with its own specific configuration (for example, different routing tables).

Overall, the built-in ability to configure applications and the fact that we have built our software as an umbrella application gives us plenty of options when deploying the software. We can:

* deploy the umbrella application to a node that will work as both TCP server and key-value storage

* deploy the `:kv_server` application to work only as a TCP server as long as the routing table points only to other nodes

* deploy only the `:kv` application when we want a node to work only as storage (no TCP access)

As we add more applications in the future, we can continue controlling our deploy with the same level of granularity, cherry-picking which applications with which configuration are going to production. We can also consider building multiple releases with a tool like [exrm](https://github.com/bitwalker/exrm), which will package the chosen applications and configuration, including the current Erlang and Elixir installations, so we can deploy the application even if the runtime is not pre-installed on the target system.

Finally, we have learned some new things in this chapter, and they could be applied to the `:kv_server` application as well. We are going to leave the next steps as an exercise:

* change the `:kv_server` application to read the port from its application environment instead of using the hardcoded value of 4040

* change and configure the `:kv_server` application to use the routing functionality instead of dispatching directly to the local `KV.Registry`. For `:kv_server` tests, you can make the routing table simply point to the current node itself

## 10.7 Summing up

In this chapter we have built a simple router as a way to explore the distributed features of Elixir and the Erlang VM, and learned how to configure its routing table. This is the last chapter in our Mix and OTP guide.

Throughout the guide, we have built a very simple distributed key-value store as an opportunity to explore many constructs like generic servers, event managers, supervisors, tasks, agents, applications and more. Not only that, we have written tests for the whole application, getting familiar with ExUnit, and learned how to use the Mix build tool to accomplish a wide range of tasks.

If you are looking for a distributed key-value store to use in production, you should definitely look into [Riak](http://basho.com/riak/), which also runs in the Erlang VM. In Riak, the buckets are replicated, to avoid data loss, and instead of a router, they use [consistent hashing](http://en.wikipedia.org/wiki/Consistent_hashing) to map a bucket to a node. A consistent hashing algorithm helps reduce the amount of data that needs to be migrated when new nodes to store buckets are added to your infrastructure.
